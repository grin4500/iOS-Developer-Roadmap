Array - это универсальный контейнер общего назначения для хранения упорядоченной коллекции элементов. Имеет фиксированный размер. 
Протоколы:
Sequence(последовательность) - означает, что можно выполнить итерацию по обьетку по крайней мере один раз
Collection - Последовательность, элементы которой могут быть пройдены несколько раз неразрушающим образом и доступны по индексированному нижнему индексу.
BidirectionalCollection - Если предыдущий протокол Collection заявлял возможность вычисления индексов в одном направлении, то протокол BidirectionalCollection, который наследуется от Collection, то данный протокол добавляет простую возможность — функция получения индексов в обратном направлении — с конца в начало (старая возможность получения с начала в конец конечно же остается, как и все фишки Sequence перебора элементов). Таким образом, у нас появилась функция index(before:) и по сути это единственное из новшеств, что дает этот протокол. Такая простая возможность дает нам достаточно быстро получить последний элемент last — он находится по индексу index(before: endIndex). Кроме того, теперь мы достаточно легко можем получить reversed — перевернутую в обратном порядке последовательность.
RandomAccessCollection - это свойство, на которое могут претендовать структуры данных, если они могут обрабатывать извлечение элемента за постоянное время. Получение элемента из массива с использованием его нижнего индекса (т. Е. array[2]) занимает постоянное время. Опять же, эту производительность не следует принимать как должное. Другие структуры данных, такие как связанные списки и деревья, не имеют постоянного временного доступа.
Смысл этого протокола — в объявлении, что основные функции работы с индексами index(_:offsetBy:) и distance(from:to:) должны работать за время O(1), т.е. протокол говорит, что теперь никаких переборов индексов — все индексы должны вычисляться сразу за O(1).
Операции: 
get/set(достать/задать элемент) - всегда O(1)
append(вставить в конец) - если надо увеличить размер массива O(n), если не надо увеличивать O(1)
insert(вставка по индексу) - O(n), insert(0, “test”) - чтобы вставить элемент, мы берем значения от вставляемого индекса до конца и копируем их, а далее вставляем нужный элемент по индексу и вставляем копируемые элементы на сдвинутые вправо индексы. (По сути сначала копируем, вставляем и увеличиваем размер массива, если необходимо)
delete(удаление по индексу) - O(n), сдвигаем все элементы правее индекса удаления, то есть перезаписываем каждый элемент правее.
Рост массива  - O(n), создается новый массив с размерностью X2, старый массив копируется в новый, получается каждый элемент массива должен быть посещен и скопирован в новый(посещение и копирование O(1))
